# Lab6 调度实验报告

- 学号：2310675
- 实验：Lab 6 处理器调度（调度器框架 + RR）
- 代码目录：`lab6/`

## 一、完成情况概述

本实验要求在 ucore 调度器框架下实现 Round-Robin（RR）时间片轮转调度，并在练习0中合入 LAB2~LAB5 的必要代码以保证系统可编译运行。

已完成：

- 练习0：补全与调度相关的进程控制块初始化、补全 LAB5 中 `copy_range()` 等必要代码，使 lab6 能独立编译
- 练习1（理解题）：对 `sched_class/run_queue` 以及 `sched_init/wakeup_proc/schedule` 的调用关系进行分析（见下文）
- 练习2：实现 RR 调度类接口（`default_sched.c`）

未完成：

- 扩展练习 Challenge1 2

## 二、关键代码修改点

- `lab6/kern/schedule/default_sched.c`
  - 实现 `RR_init/RR_enqueue/RR_dequeue/RR_pick_next/RR_proc_tick`
- `lab6/kern/trap/trap.c`
  - 在时钟中断中：`clock_set_next_event()`、`ticks++`、按 `TICK_NUM` 打印、调用 `sched_class_proc_tick(current)`
- `lab6/kern/process/proc.c`
  - `alloc_proc()`：补全 LAB4/LAB5 初始化，并增加 LAB6 调度相关字段初始化（`rq/run_link/time_slice/lab6_stride/lab6_priority`）
  - `proc_run()`：切换 `satp` 后 `flush_tlb()` 并 `switch_to()`
  - `do_fork()`：补全创建子进程的 1~7 步
  - `load_icode()`：切换页表后 `flush_tlb()`；正确设置用户态 `trapframe`（`sp/epc/status`）
- `lab6/kern/mm/pmm.c`
  - `copy_range()`：补全 LAB5 页复制 + 映射逻辑，保证 `fork()` 后子进程地址空间正确

## 三、练习1：调度器框架理解题

### 1）`sched_class` 各函数指针作用与调用时机

`struct sched_class` 把“调度策略”抽象成一组接口，使得调度器框架（`sched.c`）不依赖具体算法：

- `init(rq)`：初始化运行队列结构（在 `sched_init()` 中调用一次）
- `enqueue(rq, proc)`：将可运行进程加入运行队列（典型：`wakeup_proc()`、`schedule()` 中把当前进程重新入队）
- `dequeue(rq, proc)`：将某个进程从运行队列移除（典型：`schedule()` 选中下一个进程后将其出队）
- `pick_next(rq)`：从运行队列中选择下一个要运行的进程（在 `schedule()` 中调用）
- `proc_tick(rq, proc)`：时钟滴答到来时更新进程时间片/调度相关状态（在时钟中断里经 `sched_class_proc_tick()` 调用）

使用函数指针的原因：

- 解耦：框架只依赖接口，不关心 RR/Stride 的内部数据结构与逻辑
- 可扩展：新增算法只需实现一套 `sched_class` 并在 `sched_init()` 绑定即可
- 便于复用：同一套 `schedule()` 逻辑可对应多种算法

### 2）`run_queue` 在 lab5 与 lab6 的差异

lab6 的 `struct run_queue` 同时支持两类结构：

- `run_list`：用于 RR（链表队列）
- `lab6_run_pool`：用于 Stride（优先队列/斜堆）

原因是不同调度算法对“选择下一个进程”的数据结构需求不同：RR 只需 FIFO 队列；Stride 需要快速得到最小 stride 的进程，优先队列更高效。

### 3）`sched_init()/wakeup_proc()/schedule()` 如何与算法解耦

- `sched_init()`
  - 选择一个 `sched_class`（例如 RR），设置 `rq->max_time_slice`，调用 `sched_class->init(rq)`
- `wakeup_proc(proc)`
  - 将进程置为 `PROC_RUNNABLE`，再通过 `sched_class->enqueue()` 入队（算法决定具体入队结构）
- `schedule()`
  - 把当前进程（若仍 runnable）通过 `enqueue()` 放回队列
  - 通过 `pick_next()` 选取下一个进程，随后 `dequeue()` 移除它
  - `proc_run(next)` 完成上下文切换

框架只调用 `sched_class` 的接口，而不关心 RR/Stride 的细节。

## 四、练习2：RR 调度实现说明

RR 的核心策略：

- 每个进程有 `time_slice`
- 时钟滴答到来时 `time_slice--`
- 当 `time_slice==0`，设置 `need_resched=1`
- `schedule()` 看到 `need_resched` 后会重新选择进程

对应接口实现要点：

- `enqueue`：插入队尾；若 `time_slice` 未初始化则置为 `rq->max_time_slice`
- `pick_next`：取队首
- `proc_tick`：递减时间片，耗尽则置 `need_resched`

## 五、正确性测试方法

### 1）编译

- `make -C lab6 -j4`

### 2）运行（人工观察输出）

- `make -C lab6 qemu`

lab6 默认会在 `user_main()` 中执行 `priority` 程序（或由 `TEST` 宏指定测试程序）。

可用现象判断调度正确性：

- 系统能启动并进入用户态测试程序，不发生死锁/卡死
- 多个子进程都能被轮转调度并最终退出（RR 下各进程获得 CPU 时间趋于均衡）

