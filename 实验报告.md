# Lab6 调度实验报告

- 实验：Lab 6 处理器调度（调度器框架 + RR）
- 代码目录：`lab6/`

## 一、完成情况概述

本实验要求在 ucore 调度器框架下实现 Round-Robin（RR）时间片轮转调度，并在练习0中合入 LAB2~LAB5 的必要代码以保证系统可编译运行。

已完成：

- 练习0：补全与调度相关的进程控制块初始化、补全 LAB5 中 `copy_range()` 等必要代码，使 lab6 能独立编译
- 练习1（理解题）：对 `sched_class/run_queue` 以及 `sched_init/wakeup_proc/schedule` 的调用关系进行分析（见下文）
- 练习2：实现 RR 调度类接口（`default_sched.c`）

扩展练习（报告补充）：

- Challenge1：Stride Scheduling 调度算法（实现思路 + 代码要点 + 如何切换验证）
- Challenge2：多调度算法对比（概要设计 + 可量化测试用例）

## 二、关键代码修改点

- `lab6/kern/schedule/default_sched.c`
  - 实现 `RR_init/RR_enqueue/RR_dequeue/RR_pick_next/RR_proc_tick`
- `lab6/kern/trap/trap.c`
  - 在时钟中断中：`clock_set_next_event()`、`ticks++`、按 `TICK_NUM` 打印、调用 `sched_class_proc_tick(current)`
- `lab6/kern/process/proc.c`
  - `alloc_proc()`：补全 LAB4/LAB5 初始化，并增加 LAB6 调度相关字段初始化（`rq/run_link/time_slice/lab6_stride/lab6_priority`）
  - `proc_run()`：切换 `satp` 后 `flush_tlb()` 并 `switch_to()`
  - `do_fork()`：补全创建子进程的 1~7 步
  - `load_icode()`：切换页表后 `flush_tlb()`；正确设置用户态 `trapframe`（`sp/epc/status`）
- `lab6/kern/mm/pmm.c`
  - `copy_range()`：补全 LAB5 页复制 + 映射逻辑，保证 `fork()` 后子进程地址空间正确

## 三、练习1：调度器框架理解题

本练习的核心是理解：lab6 把“调度框架”与“调度算法”解耦。框架层只做流程控制与上下文切换，算法层只负责实现一组统一接口（`sched_class`），并用合适的数据结构维护运行队列（`run_queue`）。

相关代码入口：

- 调度框架：`lab6/kern/schedule/sched.h`、`lab6/kern/schedule/sched.c`
- RR 算法：`lab6/kern/schedule/default_sched.c`
- Stride 算法：`lab6/kern/schedule/default_sched_stride.c`
- 时钟中断驱动：`lab6/kern/trap/trap.c`（`IRQ_S_TIMER` 分支）

### 1）`sched_class` 各函数指针作用、调用时机、为何用函数指针

`struct sched_class` 把“调度策略”抽象成一组接口，使得调度器框架（`sched.c`）不依赖具体算法：

> 结构体定义见：`lab6/kern/schedule/sched.h`；框架的调用位置见：`lab6/kern/schedule/sched.c`。

1. `init(rq)`
   - **作用**：初始化运行队列 `rq` 的内部结构（链表/斜堆/计数器等）。
   - **调用时机**：系统启动的调度初始化阶段。
   - **调用路径（代码）**：`sched_init()` 中 `sched_class->init(rq)`（`lab6/kern/schedule/sched.c`）。
   - **RR/Stride 对应**：`RR_init()` / `stride_init()`（各自算法文件中）。
   - **对应代码片段**（`lab6/kern/schedule/sched.c`）：

     ```c
     // 绑定调度算法（RR/Stride 只需替换这里的指针）
     sched_class = &default_sched_class;
     rq->max_time_slice = MAX_TIME_SLICE;
     sched_class->init(rq);
     ```

2. `enqueue(rq, proc)`
   - **作用**：把一个 `PROC_RUNNABLE` 的进程放入“就绪队列”，使其成为候选运行者。
   - **典型调用时机**：
     - `wakeup_proc(proc)`：睡眠/阻塞结束后唤醒，变为 runnable 时入队；
     - `schedule()`：当前进程仍 runnable 时，会被重新入队，等待下次被选中。
   - **调用路径（代码）**：
     - `wakeup_proc()` → `sched_class_enqueue(proc)` → `sched_class->enqueue(rq, proc)`（`lab6/kern/schedule/sched.c`）
     - `schedule()` 中 `sched_class_enqueue(current)`（`lab6/kern/schedule/sched.c`）
   - **RR/Stride 对应**：
     - RR：插入 `rq->run_list` 队尾并校正 `time_slice`（`RR_enqueue`）
     - Stride：插入 `rq->lab6_run_pool`（斜堆）并校正 `time_slice`（`stride_enqueue`）

3. `dequeue(rq, proc)`
   - **作用**：把某个进程从就绪队列移除。
   - **调用时机**：`schedule()` 确定了 `next` 后，会把 `next` 从队列中移除（避免“既在队列里又在 CPU 上运行”的矛盾）。
   - **调用路径（代码）**：`schedule()` → `sched_class_dequeue(next)` → `sched_class->dequeue(rq, next)`（`lab6/kern/schedule/sched.c`）
   - **设计要点**：ucore 的接口约定里，`pick_next` 只负责“选谁”，删除由 `dequeue` 完成（RR 的实现也是如此）。

4. `pick_next(rq)`
   - **作用**：从就绪队列中选出“下一个要运行的进程”。
   - **调用时机**：每次进入 `schedule()` 时。
   - **调用路径（代码）**：`schedule()` → `sched_class_pick_next()` → `sched_class->pick_next(rq)`（`lab6/kern/schedule/sched.c`）
   - **RR/Stride 对应**：
     - RR：取 `rq->run_list` 队首节点（`RR_pick_next`）
     - Stride：取斜堆堆顶（stride 最小）（`stride_pick_next`）

5. `proc_tick(rq, proc)`
   - **作用**：处理一次时钟滴答（tick），更新该算法在当前进程上的“时间片/步进”状态，并在必要时置位 `need_resched`。
   - **调用时机**：每次时钟中断触发（抢占式调度的来源）。
   - **调用路径（代码）**：
     - `trap.c` 的 `IRQ_S_TIMER` 分支里调用 `sched_class_proc_tick(current)`（`lab6/kern/trap/trap.c`）
     - `sched_class_proc_tick` 内部再调用 `sched_class->proc_tick(rq, current)`（`lab6/kern/schedule/sched.c`）
     - trap 返回用户态前，如果 `current->need_resched == 1`，则调用 `schedule()`（`lab6/kern/trap/trap.c:trap()`）

为什么要用“函数指针”而不是在 `sched.c` 里直接写算法：

- **解耦**：框架代码只写一次（`wakeup_proc/schedule`），不需要为每种算法复制一份流程。
- **可替换**：只要把 `sched_class` 指针换掉，系统立刻切换到另一套算法实现。
- **可扩展**：新增算法不需要侵入式修改框架，只要提供一个新的 `struct sched_class new_xxx_class` 并实现 5 个接口即可。
- **更像 OOP**：在 C 里用“接口 + 实现”的方式模拟多态（lab6 指导书也强调这一点）。

### 2）`run_queue` 的分析：lab5 vs lab6，为何需要“链表 + 斜堆”

`struct run_queue` 定义见 `lab6/kern/schedule/sched.h`。相对 lab5，lab6 把运行队列设计成“能同时服务不同算法”的容器，因此保留/新增了两类核心结构：

- `run_list`（链表）：**RR/FIFO** 这类算法非常适合用链表维护队列顺序，入队/出队 O(1)，取队首 O(1)。
- `lab6_run_pool`（斜堆堆顶指针）：**Stride** 需要每次快速得到“stride 最小”的进程；若用链表扫描每次 `pick_next` 需 O(n)，进程数多时开销大，因此提供 `libs/skew_heap.h` 的优先队列抽象。

为什么 lab6 的 `run_queue` 需要同时支持两种数据结构：

- 框架层统一只持有一个 `run_queue *rq`，不想因为算法不同而替换 `rq` 的类型。
- 通过在 `run_queue` 里预留算法所需字段，达到“算法切换时框架不变”的目的。
- RR/Stride 都能复用 `rq->proc_num`、`rq->max_time_slice` 等通用字段；算法只使用自己关心的那一部分结构。

### 3）框架函数分析：`sched_init()/wakeup_proc()/schedule()` 如何与算法解耦（结合代码）

1. `sched_init()`（`lab6/kern/schedule/sched.c`）

- 维护全局 `sched_class` 指针与全局运行队列 `rq`：
  - 绑定调度类：`sched_class = &default_sched_class;`（RR）
  - 设置 `rq->max_time_slice = MAX_TIME_SLICE;`
  - 调用算法初始化：`sched_class->init(rq);`
- 这说明：**框架只负责选择“当前算法是谁”，具体如何初始化队列由算法自己完成。**

2. `wakeup_proc(proc)`（`lab6/kern/schedule/sched.c`）

- 将 `proc->state` 变为 `PROC_RUNNABLE`
- 通过 `sched_class_enqueue(proc)` 间接调用 `sched_class->enqueue(rq, proc)` 入队
- 入队细节（插链表/插斜堆）完全由算法实现决定，框架不关心。

3. `schedule()`（`lab6/kern/schedule/sched.c`）

`schedule()` 的关键流程（与算法解耦的核心点）：

- `current->need_resched = 0;`：清除重调度标志
- 若 `current->state == PROC_RUNNABLE`：`enqueue(current)`（把当前进程放回就绪队列）
- `next = pick_next()`：由算法选出下一个进程
- 若 `next != NULL`：`dequeue(next)`（把 next 从就绪队列移除）
- 若 `next == NULL`：选择 `idleproc`
- `proc_run(next)`：完成进程切换（切换页表、flush_tlb、switch_to）

其中 `enqueue/pick_next/dequeue` 全部是通过 `sched_class` 的函数指针调用，因此 `schedule()` 逻辑对 RR/Stride 都通用。

框架只调用 `sched_class` 的接口，而不关心 RR/Stride 的细节。

补充：`schedule()` 的关键“解耦调用点”在源码中非常直观（`lab6/kern/schedule/sched.c`）：

```c
current->need_resched = 0;
if (current->state == PROC_RUNNABLE) {
    sched_class_enqueue(current);      // -> sched_class->enqueue(rq, current)
}
if ((next = sched_class_pick_next()) != NULL) { // -> sched_class->pick_next(rq)
    sched_class_dequeue(next);         // -> sched_class->dequeue(rq, next)
}
if (next == NULL) next = idleproc;
if (next != current) proc_run(next);
```

### 4）调度类初始化流程：从内核启动到调度器 ready

按“真实调用链”描述如下（结合当前代码）：

1. 内核启动后完成基础初始化（内存管理、进程管理等）
2. 调用 `sched_init()` 初始化调度器框架与绑定算法（`lab6/kern/schedule/sched.c`）
3. 在 `sched_init()` 中：
   - `sched_class = &default_sched_class;` 绑定 RR 的实现（`default_sched_class` 定义在 `lab6/kern/schedule/default_sched.c`）
   - `sched_class->init(rq)` 调用到 `RR_init(rq)`，初始化 `rq->run_list/proc_num` 等结构
4. 完成后，系统进入“可通过 schedule() 进行进程选择与切换”的状态。

关键点：`default_sched_class` 并不是在框架里硬编码 RR 逻辑，而是“一个实现了接口的对象”，框架只保存其指针并调用接口。

### 5）进程调度流程图：timer → proc_tick → need_resched → schedule（含接口调用顺序）

下面给出一个结合代码的“完整调度链路图”（强调调用顺序与 `need_resched` 的作用）：

```
（硬件/平台定时器触发）
时钟中断 IRQ_S_TIMER
    ↓  lab6/kern/trap/trap.c
clock_set_next_event(); ticks++;
    ↓
sched_class_proc_tick(current)
    ↓  lab6/kern/schedule/sched.c
sched_class->proc_tick(rq, current)
    ↓  RR_proc_tick / stride_proc_tick
time_slice-- ; if time_slice==0 => current->need_resched=1
    ↓
trap() 返回用户态前检查 need_resched
    ↓  lab6/kern/trap/trap.c:trap()
if (!in_kernel && current->need_resched) schedule();
    ↓  lab6/kern/schedule/sched.c:schedule()
enqueue(current if runnable)
    ↓
next = pick_next()
    ↓
dequeue(next)
    ↓
proc_run(next) => 切页表/flush_tlb/switch_to
```

`need_resched` 的作用总结：

- `proc_tick` 只负责“设置标志位”，不直接切换（避免在中断/临界区的危险位置切换）
- trap 返回用户态前是一个“安全点”，统一检查并执行 `schedule()`，从而实现抢占式调度的正确性与可控性

### 6）调度算法的切换机制：如何添加新算法（以 Stride 为例）

把 RR 切换为 Stride 的最小改动（当前代码即如此）：

1. 提供一个新的 `struct sched_class stride_sched_class`（已在 `lab6/kern/schedule/default_sched_stride.c` 中提供）
2. 在 `sched_init()` 中把绑定从 RR 改为 Stride：
   - `sched_class = &default_sched_class;`
   - 改为：`sched_class = &stride_sched_class;`

如果要添加一个全新的算法 `xyz`，一般需要：

- 新建 `kern/schedule/default_sched_xyz.c`（或其他命名），实现 `init/enqueue/dequeue/pick_next/proc_tick`
- 定义并导出 `struct sched_class xyz_sched_class`
- 在 `kern/schedule/default_sched.h` 声明 `extern struct sched_class xyz_sched_class;`
- 在 `sched_init()` 选择绑定：`sched_class = &xyz_sched_class;`

之所以“切换容易”，原因正是框架只依赖 `sched_class` 的统一接口：框架流程不变，替换实现即可。

## 四、练习2：RR 调度实现说明

本练习需要在调度框架提供的 `sched_class` 接口下，补全 RR（Round-Robin）调度器，使其能被框架透明调用。

RR 的代码位置与绑定关系：

- RR 调度算法实现：`lab6/kern/schedule/default_sched.c`
- 调度类对象：`default_sched_class`（`.name="RR_scheduler"`，包含 `init/enqueue/dequeue/pick_next/proc_tick` 五个函数指针）
- 框架调用入口：`lab6/kern/schedule/sched.c:schedule()` 与 `sched_class_proc_tick()`
- tick 驱动入口：`lab6/kern/trap/trap.c` 的 `IRQ_S_TIMER` 分支调用 `sched_class_proc_tick(current)`

### 1）RR 使用的数据结构（结合代码）

RR 需要一个“就绪队列”，用链表维护所有 `PROC_RUNNABLE` 的候选进程：

- `struct run_queue`（`lab6/kern/schedule/sched.h`）
  - `run_list`：RR 的就绪队列（双向循环链表表头）
  - `proc_num`：队列中进程数量（用于统计/断言）
  - `max_time_slice`：每个进程的默认时间片上限
- `struct proc_struct`（`lab6/kern/process/proc.h`）
  - `run_link`：嵌入到 `run_list` 的链表节点
  - `rq`：指向所属 `run_queue`（一致性检查/算法需要）
  - `time_slice`：剩余时间片计数
  - `need_resched`：需要重新调度的标志位

### 2）RR 五个接口的“语义 + 代码实现要点”

#### (1) `RR_init(rq)`：初始化运行队列

对应代码：`lab6/kern/schedule/default_sched.c:RR_init`

做两件事：

- `list_init(&rq->run_list)`：把就绪队列置空（只有表头）
- `rq->proc_num = 0`：清空队列计数

`max_time_slice` 在框架 `sched_init()` 里先赋值（`rq->max_time_slice = MAX_TIME_SLICE`），所以 RR_init 不需要管它。

#### (2) `RR_enqueue(rq, proc)`：把 runnable 进程入队（队尾）

对应代码：`lab6/kern/schedule/default_sched.c:RR_enqueue`

关键点：

- 断言 `assert(list_empty(&proc->run_link))`：保证该进程不在任何就绪队列中，避免链表重复挂载导致死循环/破坏结构
- `list_add_before(&rq->run_list, &proc->run_link)`：插入到表头之前，即“队尾”（FIFO）
- 时间片校正：如果 `proc->time_slice == 0`（新入队/时间片耗尽）或 `proc->time_slice > rq->max_time_slice`（异常值），则重置为 `rq->max_time_slice`
- 维护元数据：`proc->rq = rq`，`rq->proc_num++`

为什么要在 enqueue 时重置 `time_slice`：RR 的“轮转”语义是“每次重新进入就绪队列就重新获得一个完整时间片”，否则某些进程会带着 0 时间片入队，下一次刚被选中就立刻触发重调度。

#### (3) `RR_pick_next(rq)`：选择下一个运行进程（队首）

对应代码：`lab6/kern/schedule/default_sched.c:RR_pick_next`

做法：

- `le = list_next(&rq->run_list)` 取队首节点
- 若 `le != &rq->run_list` 说明队列非空，返回 `le2proc(le, run_link)`
- 否则返回 `NULL`（框架会回退到 `idleproc`）

注意：在 ucore 的接口约定里，`pick_next` 只“挑选”，不负责把节点从队列删除；真正删除在 `dequeue` 里做，且由框架 `schedule()` 统一调用，这样不同算法都能复用同一套框架流程。

#### (4) `RR_dequeue(rq, proc)`：把进程从就绪队列移除

对应代码：`lab6/kern/schedule/default_sched.c:RR_dequeue`

关键点：

- 断言 `!list_empty(&proc->run_link)` 与 `proc->rq == rq`（一致性）
- `list_del_init(&proc->run_link)`：从链表摘除并把节点重新初始化为空
- `rq->proc_num--`

#### (5) `RR_proc_tick(rq, proc)`：tick 里递减时间片并置位 need_resched

对应代码：`lab6/kern/schedule/default_sched.c:RR_proc_tick`

逻辑：

- 若 `proc->time_slice > 0`：`proc->time_slice--`
- 若 `proc->time_slice == 0`：`proc->need_resched = 1`

这里“只置位，不直接切换”的原因：tick 发生在中断上下文里，直接切换可能破坏内核临界区；ucore 选择在 trap 返回用户态之前的安全点统一检查 `need_resched` 并调用 `schedule()`。

### 3）RR 在框架中的完整工作流程（与练习1的流程对齐）

把 RR 放到框架里看，完整链路是：

1. 时钟中断触发（`lab6/kern/trap/trap.c:IRQ_S_TIMER`）  
2. 调用 `sched_class_proc_tick(current)`（`lab6/kern/schedule/sched.c`）  
3. 进入 RR 的 `RR_proc_tick(rq, current)`：递减 `time_slice`，必要时置 `need_resched=1`  
4. trap 返回用户态前检查到 `need_resched==1`，进入 `schedule()`（`lab6/kern/schedule/sched.c`）  
5. `schedule()` 内部按统一顺序调用：
   - 若 `current` 仍 `PROC_RUNNABLE`：`RR_enqueue(rq, current)`（把当前进程放回队尾）
   - `next = RR_pick_next(rq)`（取队首）
   - `RR_dequeue(rq, next)`（把 next 从队列摘下，准备运行）
   - `proc_run(next)`（上下文切换）

RR 的核心策略可以概括为一句话：**tick 负责“消耗时间片并提出调度请求”，schedule 负责“把当前进程放回队尾并切换到队首进程”。**

## 五、正确性测试方法

### 1）编译

- `make -C lab6 -j4`

### 2）运行（人工观察输出）

- `make -C lab6 qemu`

lab6 默认会在 `user_main()` 中执行 `priority` 程序（或由 `TEST` 宏指定测试程序）。

可用现象判断调度正确性：

- 系统能启动并进入用户态测试程序，不发生死锁/卡死
- 多个子进程都能被轮转调度并最终退出（RR 下各进程获得 CPU 时间趋于均衡）

### 3）评分脚本（make grade）

在 `lab6/` 下执行：`make grade`

评分结果（本地运行）：

```text
priority:                (3.1s)
  -check result:                             OK
  -check output:                             OK
Total Score: 50/50
```

## 六、扩展练习 Challenge1：Stride Scheduling（需要编码）的实现说明

> 说明：本节对应指导书 “Challenge1：实现 Stride Scheduling”。Stride 调度器代码已在 `lab6/kern/schedule/default_sched_stride.c` 中补全；为兼容评分脚本与展示效果，`lab6/kern/schedule/sched.c:sched_init()` 中做了区分：`make grade`（`-DDEBUG_GRADE`）绑定 RR，普通 `make qemu` 默认绑定 Stride。

### 1）核心思想与字段含义

Stride 的目标是实现“CPU 时间份额 ∝ priority”的可控公平性。

- `proc->lab6_priority`：优先级（>0，越大越“重要”）
- `proc->lab6_stride`：步进值（累计的 pass/stride，越小越优先被调度）
- `BIG_STRIDE`：足够大的常数，把分数变成整数增量：`stride += BIG_STRIDE / priority`

每次调度选择 `lab6_stride` 最小的进程运行；运行后更新其 `lab6_stride`，使其“变大一些”，从而让出机会给其它进程。

### 2）为什么“时间片数 ∝ priority”（直观说明）

对进程 P：

- 每次被调度后增加 `ΔP = BIG_STRIDE / P.priority`
- priority 越大，Δ 越小，stride 增长越慢，更容易保持“最小”
- 长期来看，为保持各进程 stride 接近，priority 大的进程需要被调度更多次

因此调度次数（时间片数）会趋近于 priority 的比例。

### 3）数据结构：为什么用 skew heap（斜堆）

如果每次 `pick_next` 都扫描链表找最小 stride，复杂度是 O(n)。

使用 `libs/skew_heap.h`：

- `enqueue`：`skew_heap_insert` 插入
- `pick_next`：堆顶就是最小 stride 的进程
- `dequeue`：`skew_heap_remove`

与指导书给出的伪代码一致，且更高效。

### 4）接口实现要点（对应 `sched_class`）

在 `lab6/kern/schedule/default_sched_stride.c` 中：

- `stride_init`：初始化 `rq->run_list`，`rq->lab6_run_pool=NULL`，`rq->proc_num=0`
- `stride_enqueue`：插入优先队列；校正 `proc->time_slice`；维护 `rq->proc_num`
- `stride_dequeue`：从优先队列删除；维护 `rq->proc_num`
- `stride_pick_next`：取最小 stride 的进程，并执行 `proc->lab6_stride += BIG_STRIDE / proc->lab6_priority`
- `stride_proc_tick`：时间片递减，耗尽则 `proc->need_resched=1`

### 5）如何切换到 Stride 并验证

修改 `lab6/kern/schedule/sched.c:sched_init()`：

- 将 `sched_class = &default_sched_class;` 改为 `sched_class = &stride_sched_class;`

然后运行 `priority` 程序：

- RR 预期输出：`sched result: 1 1 1 1 1`
- Stride 预期输出：会出现“非均等”的分配比例（指导书示例为 `1 1 2 2 3` 一类）


## 七、扩展练习 Challenge2：多调度算法与测试用例（概要）

本 Challenge 的目标是：在 ucore 的调度框架（`sched_class`）上实现多种调度算法，并通过一组可重复的 workload 给出可量化对比结论（吞吐/响应/公平/饥饿等）。

本报告结合我们已经“实际实现并能运行”的 **FIFO/FCFS** 调度器，给出更具体的实现与测试思路（其余算法给出可扩展方向）。

### 1）我们实际实现的算法：FIFO（FCFS，先来先服务）

#### 1.1 设计语义（最关键点：非抢占）

FIFO/FCFS 的语义可以概括为：

- 就绪队列按“进入队列的先后顺序”排队；
- 每次调度选择队首进程运行；
- **非抢占**：时钟 tick 不会强制切换当前进程；只有当当前进程主动让出/阻塞/退出时才会发生 `schedule()`。

这也是 FIFO 与 RR/Stride 的本质区别：RR/Stride 依赖时间片与 tick 实现周期性抢占，而 FIFO 更像“谁先来谁一直跑”。

#### 1.2 代码落点与接口对应（结合 sched_class）

实现文件：`lab6_beifen/kern/schedule/default_sched_fifo.c`

对应 `sched_class` 五个接口的实现要点：

- `init(rq)`：初始化 `rq->run_list`，清零 `rq->proc_num`（并将 `rq->lab6_run_pool` 置空以避免未初始化字段）
- `enqueue(rq, proc)`：把 `PROC_RUNNABLE` 进程插入队尾（`list_add_before`），`proc_num++`
- `pick_next(rq)`：取队首（`list_next`）作为 next
- `dequeue(rq, proc)`：从链表删除被选中的进程，`proc_num--`
- `proc_tick(rq, proc)`：**空实现**（不递减时间片、不置 `need_resched`），保证 FIFO 的非抢占语义

绑定位置：`lab6_beifen/kern/schedule/sched.c:sched_init`

我们通过切换 `sched_class` 指针选择 FIFO，并且启动时会打印：

- `sched class: FIFO_scheduler`

这行输出是“FIFO 是否真正生效”的最直接证据。

### 2）为什么 FIFO 适合做定量对比（它会暴露什么问题）

FIFO 的优点是实现简单、上下文切换少（开销低），但它会明显暴露：

- **响应时间差**：如果第一个 CPU-bound 任务很长，后续任务首响应会极差
- **饥饿问题**：后来的短任务可能长时间拿不到 CPU
- **对交互任务不友好**：I/O/交互任务可能被长计算任务“堵住”

因此 FIFO 非常适合作为 Challenge2 的“对照组”，与 RR（公平）/Stride（按权重公平）对比。

### 3）可量化指标（metrics，如何从输出计算）

为了做到“定量分析”，建议至少收集以下指标：

- **周转时间 TAT**：`finish_time - start_time`（越小越好）
- **响应时间 RT**：`first_run_time - start_time`（交互性，越小越好）
- **吞吐量 TH**：固定时间窗口内完成的进程数（越大越好）
- **公平性 Fairness**：
  - RR：看各进程运行量（如 acc）是否接近
  - Stride：看运行量是否近似满足 `share ∝ priority`
- **饥饿/尾延迟**：是否存在某些进程长期不被调度（RT/TAT 极大）
- **调度开销**：上下文切换次数（可通过 runs 计数或日志推断；抢占越频繁通常开销越大）

### 4）测试用例与预期现象（结合已有 user 程序）

#### 4.1 CPU-bound（长短混合）对比：验证 FIFO 的“短作业被堵住”

设计：准备若干纯计算子进程，其中一个“很长”，其余“很短”，记录每个进程的 start/finish。

预期：

- FIFO：后来的短作业 TAT/RT 会显著变差（因为长作业先来先跑）
- RR：短作业不会被长期堵住，完成顺序更平均
- Stride：如果给短作业更高 priority，则短作业更容易先完成

#### 4.2 交互型（频繁 yield）对比：验证响应时间

设计：交互任务周期性 `yield()`/短计算后打印；同时混入一个 CPU-bound 长任务。

预期：

- FIFO：交互任务如果不是最先运行，首响应可能被严重推迟
- RR：交互任务能周期性获得 CPU，响应更稳定

#### 4.3 使用现有 priority 程序观察 FIFO 的“极端不公平”现象（我们已经实际跑到）

`priority` 原本是为了验证 RR/Stride 的份额分配，但在 FIFO（非抢占）下会出现非常典型的现象：

- 第一个跑到 CPU 的子进程会长时间独占，`acc` 极大；
- 其它子进程直到很晚才开始运行，且由于全局时间已接近阈值，往往很快就退出，`acc` 很小；
- 最终 `sched result` 可能出现类似 `1 0 0 0 0` 的极端分布。

这恰好说明 FIFO 对“公平性/响应时间”的缺陷，是 Challenge2 里非常有代表性的对比结论。

##### 4.3.1 我们的实际运行输出与解释（FIFO + priority）

本次实际输出片段如下（关键行）：

```text
sched class: FIFO_scheduler
kernel_execve: pid = 2, name = "priority".
...
child pid 3, acc 4704000, time 2010
child pid 4, acc 4000, time 2010
child pid 5, acc 4000, time 2010
child pid 6, acc 4000, time 2010
child pid 7, acc 4000, time 2020
...
sched result: 1 0 0 0 0
```

解释（为什么会这样）：

1. `sched class: FIFO_scheduler` 说明调度器确实已切换为 FIFO。
2. FIFO 是**非抢占式**：时钟 tick 不会让当前进程被强制换下（`proc_tick` 不会设置 `need_resched`），因此**先获得 CPU 的子进程会持续运行**，直到它自己退出/阻塞/主动让出。
3. `priority.c` 子进程的退出判定不是“每次循环都检查时间”，而是 **每当 `acc % 4000 == 0` 才检查一次 `gettime_msec()`**：
   - 第一个运行的子进程（这里是 pid=3）几乎独占 CPU，于是在 2000ms 之前把 `acc` 累积到非常大（`4704000`）。
   - 其它子进程被调度到时，全局时间已经接近/超过 2000ms，它们往往只跑到第一次 `acc==4000` 就立刻触发检查并退出，因此 `acc` 都停在 `4000`。
4. `sched result` 的计算是以 `status[0]`（第一个子进程的 acc）为基准做整数比例：
   - `4000 / 4704000 ≈ 0`，因此后四个显示为 0，得到 `1 0 0 0 0`。

结论：该输出符合 FIFO/FCFS 的预期行为，并直观展示了 FIFO 在 CPU-bound 场景下的“极端不公平/响应差”（短作业被长作业堵住）的缺陷，也说明 `priority` 更适合用于验证 RR/Stride，而在 FIFO 下会放大出其非抢占特征。

### 5）扩展方向（其余算法如何放到同一对比框架）

在同一 `sched_class` 框架下，其余算法可按如下思路扩展：

- **SJF**：需要“作业长度估计值”；就绪队列用优先队列按估计值最小者先跑；可做非抢占（SJF）或抢占（SRTF）
- **MLFQ**：多级队列 + 时间片递减 + 用尽降级 + 周期性提升（aging）避免饥饿
- **HPF**：优先级最高者先跑，需考虑优先级反转/饥饿与 aging

这些算法都可以复用上面同一套 metrics/workloads，从而形成“可量化对比表格与适用范围总结”。
